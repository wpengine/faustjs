---
slug: /gutenberg/tutorial/create-a-custom-block
title: Creating a Custom Block
description: This tutorial will give you some simple steps to follow in order to build your own completely custom block
---

In this tutorial, you will install and create a block using `@faustwp/blocks`.
This tutorial assumes you have already manually installed both the `@faustwp/blocks` and `wp-graphql-content-blocks` plugin. If you aren't sure how, head to the [Getting Started](/docs/gutenberg/getting-started) guide for step-by-step instructions.

This tutorial also utilizes the [Faust Scaffold](http://localhost:3000/blog/sprint-24-update#faustjs-scaffold) as its repository. Feel free to [clone](https://github.com/wpengine/faust-scaffold) this repository to follow along.

## 1. Do I have everything I need to create a custom block?

Before beginning, take stock of your activated plugins in your WordPress instance. Faust, WPGraphQL, and [WPGraphQL Content Blocks](/docs/gutenberg/wp-graphql-content-blocks.mdx) all need to be installed and active before you move forward. Be sure to install the `@faustwp/blocks` package at your app's root level as well.

## 2. Defining your custom block

In this tutorial, we will assume that you do not have a preexisting block in mind to use with your Decoupled site. If you have a block you want to emulate from the WordPress core blocks library, head to our [tutorial](/docs/gutenberg/tutorial/create-a-block-from-wordpress-core.mdx) to learn how to do exactly that. Likewise, if you need to recreate a block used by a third party plugin, we have a [tutorial](/docs/gutenberg/tutorial/create-a-block-from-third-party.mdx) tailored for that process, too.

This tutorial assumes that you begin your block creation from nothing at all, which will therefore require a slightly different set of steps. 

:::tip 

Check out all the components that are available to you through the [@wordpress/components](https://developer.wordpress.org/block-editor/reference-guides/packages/packages-components/) library as you think about what you want your custom block to do and look like. 

:::

## 3. Creating your block using the WordPress block boilerplate code

The [@wordpress/create-block](https://www.npmjs.com/package/@wordpress/create-block) package exists to create the necessary block scaffolding to get you started. See the WordPress basic block [tutorial](https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/) documentation for a step-by-step guide.

For this step, we will make a simple block named MyCoolBlock, which has a message that takes text, a radio control input attribute from the [@wordpress/components](https://wordpress.github.io/gutenberg/?path=/story/components-radiocontrol--default) library, and a RichText attribute from the [@wordpress/block-editor](https://developer.wordpress.org/block-editor/reference-guides/richtext/) toolkit applied to another text field. This block should closely match your boilerplate code's styling:


<a href="/docs/img/custom-block-in-editor.png" target="_blank">
  <img
    src="/docs/img/custom-block-in-editor.png"
    alt="The custom block as seen in the editor window"
  />
</a>

## 4. Create the initial block

Inside the codebase of your application, create the basic block structure that simply prints the block's attributes.
The steps required to achieve that are the following:

### 4.1 Save the block inside a folder called `wp-blocks`

<a href="/docs/img/creating-wp-blocks-folder.png" target="_blank">
  <img
    src="/docs/img/creating-wp-blocks-folder.png"
    alt="The file structure of the project, showing the newly created wp-blocks folder at the root level of the Faust Scaffold app and containing a newly created folder called MyCoolBlock.js."
  />
</a>

```jsx title="wp-blocks/MyCoolBlock.js"
export default function MyCoolBlock(props) {
  console.log(props.attributes);
  return <div>MyCoolBlock</div>
}
```

This component prints the block attributes via the props passed as a parameter. This will help us understand what is happening a little later on.

### 4.2 Export the block in the `index.js`

Make another file in `wp-blocks`, called `index.js`, and place the following inside:

```jsx title="wp-blocks/index.js"
import MyCoolBlock from './MyCoolBlock';
export default {
  MyCoolBlock
}
```

By exporting the block in the `index.js`, we make it available in the `WordPressBlocksProvider`.

### 4.3 Create the block fragment

You want to create a fragment that describes the request block fields and attributes. Ideally you want to include all the relevant fields for the implementation part:

```jsx title="wp-blocks/MyCoolBlock.js" {1}
import {gql} from '@apollo/client';
...
MyCoolBlock.fragments = {
  key: `MyCoolBlockBlockFragment`,
  entry: gql`
    fragment MyCoolBlockBlockFragment on MyCoolBlock {
      attributes {
        color
        content
        message
      }
    }
  `,
};
```
We chose to attach the fragment as a property of the function component itself. This follows best practice for creating [colocated fragments](https://www.apollographql.com/docs/react/data/fragments/#creating-colocated-fragments).

### 4.4 Include the block fragment into the page query string

You want to include the fragment in the page query string and reference the block fragment key so that when the page resolves, the payload includes the data from that block.

In our example we use it in both the Posts and Pages templates when using the [Faust Template Hierarchy](/docs/templates):

```jsx {1,7,18} title="wp-templates/single.js"
import blocks from '../wp-blocks';
export default function Component(props) {
...
}
Component.query = gql`
...
${blocks.MyCoolBlock.fragments.entry}
query GetPost(
...
	post(id: $databaseId, idType: DATABASE_ID, asPreview: $asPreview) {
		...
		contentBlocks {
			name
			__typename
			renderedHtml
			id: nodeId
			parentId
			...${blocks.MyCoolBlock.fragments.key}
      	}
	}
...
}
```

If you navigate to the page that contains this block, you should be able to inspect the properties in the console:

<img
    src="/docs/img/mycoolblock-attributes.png"
    alt="Preview of the MyCoolBlock attributes in the console"
  />

## 5. Implement the Block using the provided block attributes and the Editor view

Let's look at the following files you generated during your custom block creation:

`style.scss`: Contains the front-end block styles. You can definitely include those in the global styles section of your app, if you wish:

```scss title="style.scss"


...
```

`block.js`: Contains the block attributes specification.

`save.js`: According to [the docs](https://developer.wordpress.org/block-editor/reference-guides/block-api/block-edit-save/#save),
the `save` function defines the way in which the different attributes should be combined into the final markup, which is then serialized into `post_content`.

Most of the time, the `save` function contains the actual implementation of the block, so you can take this markup and adopt it. This way, the design of the block in the editor will match the design we make in the Decoupled site.

So go ahead and provide the implementation of the Block based on the `save` function. 

```jsx title="wp-blocks/MyCoolBlock.js" {6}
import { gql } from '@apollo/client';

export default function MyCoolBlock(props) {
  const className = 'my-block-code';
  return (
    <p className={className}>{props?.content}</p>
      <code>{`${props.attributes?.content}`}</code>
    </pre>
  );
}
```



Now that you have the styles configured correctly, you can navigate into the Headless site's page and check that the block matches the styling you wish. Make sure to tweak the block in the editor and verify that the changes are being reflected in the website.

:::note

Next.js won't allow you to import the `styles.scss` directly into the component since it requires all
global CSS to be imported from the pages directory only. See the [related error](https://nextjs.org/docs/messages/css-global) message.
So you need to either import the styles from a global module or translate the styles to use Component-Level CSS.

:::

## Further Considerations

### Can I style the block differently?

Yes, you can style the block in many ways, choosing to ignore some of the attributes altogether.
You can also use an external React Library to style the block. For example, use Material UI or ChakraUI.
Bear in mind that this will almost always result in degraded user editing experience as the styles of the Editor view won't match the styles of the rendered page.






