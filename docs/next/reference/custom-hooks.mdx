---
slug: /next/reference/custom-hooks
title: Useful Hooks For Data Fetching With Faust.js
description: Faust.js makes fetching data from Headless WordPress incredibly easy with special hooks.
---

When you use `getClient` from Faust.js to generate a GQty client, you will get some additional hooks that you can use to make your client more useful and make fetching data from Headless WordPress easier. The following hooks are available on the `client` object generated by `getClient`.

### `usePost`

The `usePost` hook provides the standard interface for getting a post from your Headless WordPress API. It also allows you to pass-in no arguments. When you do not pass arguments into `usePost` it will attempt to look at the URL params in order to determine how to get a post from your Headless WordPress API. In Next.js this means you will need to name your post page file in a particular way in order to get the proper URL params. Below are the possible names that will work automatically with Faust.js:

- `[postId].tsx`
- `[postSlug].tsx`
- `[...postUri].tsx`

Using the above names, Faust.js is able to apply the following logic to determine how to get a post from your Headless WordPress API:

1. If `postId` is found in the URL params, Faust.js makes a request to retrieve a `post` from WordPress by `ID`
1. If `postSlug` is found in the URL params, Faust.js makes a request to retrieve a `post` from WordPress by `SLUG`
1. If `postUri` is found in the URL params, Faust.js makes a request to retrieve a `post` from WordPress by `URI`

The following is an example of how to use the `usePost` hook with a `postSlug`:

```tsx title=/src/pages/posts/[postSlug].tsx {5,6}
import { getNextStaticProps } from '@faustjs/next';
import { client } from 'client';

export default function Page() {
  const { usePost } = client;
  const post = usePost();

  return (
    <article>
      <h1>{post?.title()}</h1>
      <div dangerouslySetInnerHTML={{ __html: post?.content() }} />
    </article>
  );
}
```

The above code will also work with `postId` and `postUri` depending upon what URL scheme you want to use. You may also want to fetch a specific post. Doing that might look similar to the following:

```tsx {6-10}
import { getNextStaticProps } from '@faustjs/next';
import { GetStaticPropsContext } from 'next';
import { client, PostIdType } from 'client';

export default function Page() {
  const { usePost } = client;
  const post = usePost({
    id: 'hello-world',
    idType: PostIdType.SLUG,
  });

  return (
    <article>
      <h1>{post?.title()}</h1>
      <div dangerouslySetInnerHTML={{ __html: post?.content() }} />
    </article>
  );
}
```

### `usePosts`

The `usePosts` hook provides the standard interface for getting a list of posts from your Headless WordPress API. It also allows you to pass-in no arguments. When you do not pass arguments into `usePosts` it will attempt to look at the URL params in order to determine how to get a list of posts from your Headless WordPress API. In Next.js this means you will need to name your post page file in a particular way in order to get the proper URL params. Below are the possible names that will work automatically with Faust.js:

1. If `categoryId` is found in the URL params, a request is made to retrieve a list of posts for a `category` by `ID`
1. If `categorySlug` is found in the URL params, a request is made to retrieve a list of posts for a `category` by `SLUG`
1. If no URL params are found, a request is made to retrieve a list of posts without any filters

The following is an example of how to use the `usePosts` hook with no URL params:

```tsx title=src/pages/index.tsx {6-8,14-16}
import { getNextStaticProps } from '@faustjs/next';
import { client } from 'client';

export default function Home() {
  const { usePosts } = client;
  const posts = usePosts({
    first: 6,
  });

  return (
    <>
      <h2>Recent Posts</h2>
      <ul>
        {posts?.nodes.map((post) => (
          <li key={post.id}>{post.title()}</li>
        ))}
      </ul>
    </>
  );
}
```

The code above will get the first 6 posts from the Headless WordPress API. If you want to create a page that would pull posts associated with a specific category you can use the following code:

```tsx title=src/pages/category/[categorySlug].tsx {6-8,14-16}
import { getNextStaticProps } from '@faustjs/next';
import { client } from 'client';

export default function Home() {
  const { usePosts } = client;
  const posts = usePosts({
    first: 6,
  });

  return (
    <>
      <h2>Recent Posts</h2>
      <ul>
        {posts?.nodes.map((post) => (
          <li key={post.id}>{post.title()}</li>
        ))}
      </ul>
    </>
  );
}
```

The code above will get the first 6 posts from the Headless WordPress API that are for the `categorySlug` defined in the URL params.

For an example of `usePosts` with pagination, [take a look at our Next.js getting started example.](https://github.com/wpengine/faustjs/blob/canary/examples/next/getting-started/src/pages/posts/index.tsx#L18-L23)

### `usePage`

The `usePage` hook provides the standard interface for getting a page from your Headless WordPress API. It also allows you to pass-in no arguments. When you do not pass arguments into `usePage` it will attempt to look at the URL params in order to determine how to get a page from your Headless WordPress API. In Next.js this means you will need to name your page file in a particular way in order to get the proper URL params. Below are the possible names that will work automatically with Faust.js:

- `[pageId].tsx`
- `[...pageUri].tsx`

Using the above names, Faust.js is able to apply the following logic to determine how to get a page from your Headless WordPress API:

1. If `pageId` is found in the URL params, Faust.js makes a request to retrieve a `page` from WordPress by `ID`
1. If `pageUri` is found in the URL params, Faust.js makes a request to retrieve a `page` from WordPress by `URI`

The following is an example of how to use the `usePage` hook with a `pageUri`:

```tsx title=/src/pages/[...pageUri].tsx {5,6}
import { getNextStaticProps } from '@faustjs/next';
import { client } from 'client';

export default function Page() {
  const { usePage } = client;
  const page = usePage();

  return (
    <article>
      <h1>{page?.title()}</h1>
      <div dangerouslySetInnerHTML={{ __html: page?.content() }} />
    </article>
  );
}
```

The above code will also work with `pageId` and `pageUri` depending upon what URL scheme you want to use. You may also want to fetch a specific page. Doing that might look similar to the following:

```tsx {6-10}
import { getNextStaticProps } from '@faustjs/next';
import { GetStaticPropsContext } from 'next';
import { client, PageIdType } from 'client';

export default function Page() {
  const { usePost } = client;
  const page = usePage({
    id: 'hello-world',
    idType: PageIdType.SLUG,
  });

  return (
    <article>
      <h1>{page?.title()}</h1>
      <div dangerouslySetInnerHTML={{ __html: page?.content() }} />
    </article>
  );
}
```

### `usePreview`

The `usePreview` hook provides an abstraction around getting a preview `page` or `post` from the Headless WordPress API. When calling the `usePreview` hook on an appropriate preview page, the hook will determine if the preview is a `page` or `post` and will make a request to retrieve the proper preview content.

The following example shows how to use the `usePreview` hook to render either a `post` or `page` from WordPress:

```tsx title=src/pages/preview.tsx {14-17}
import { PageComponent } from './[...pageUri]';
import { PostComponent } from './posts/[postSlug]';
import { client } from 'client';

export default function Preview() {
  const { usePreview } = client.auth;
  const result = usePreview();

  if (client.useIsLoading() || !result) {
    return <p>loading...</p>;
  }

  if (result.type === 'page') {
    if (!result.page) {
      return <>Not Found</>;
    }

    return <PageComponent page={result.page} />;
  }

  if (!result.post) {
    return <>Not Found</>;
  }

  return <PostComponent post={result.post} />;
}
```

### `useAuth`

The `useAuth` hook provides a way to guarantee a users' authentication state, thus allowing you to control how a page's content is rendered.

The `useAuth` hook accepts 1 argument of `UseAuthOptions`, which is an object that contains the following properties:

```ts
const options = {
  // Specify if the useAuth hook should facilitate the redirect to the appropriate url.
  shouldRedirect: true;
}
```

By default, if the user is not authenticated, the page will redirect to the WordPress backend if the `authType` is `redirect`, and to the `loginPagePath` if `authType` is `local`.

However, if the `shouldRedirect` option is `false`, the `useAuth` hook will **not** facilitate the redirect.

The example below shows how to use the `useAuth` hook to render a page that requires authentication. If a user is authenticated, they will be shown the content. Otherwise, they will be redirected to the appropriate URL to authenticate:

```tsx title=src/pages/gated-content.tsx {5}
import { client } from 'client';

export default function Gated() {
  const { useAuth } = client.auth;
  const { isLoading, isAuthenticated } = useAuth();

  if (isLoading) {
    return <div>Loading...</div>;
  }

  return <div>Authenticated content</div>;
}
```

Additionally, the example below shows how to use `useAuth` with the `shouldRedirect` option set to `false`. This will disable the automatic redirect to the appropriate URL to authenticate, and allows you to control how the page's content is rendered in an unauthenticated state:

```tsx title=src/pages/gated-content.tsx {5-7,13-15}
import { client } from 'client';

export default function Gated() {
  const { useAuth } = client.auth;
  const { isLoading, isAuthenticated, authResult } = useAuth({
    shouldRedirect: false,
  });

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (!isAuthenticated) {
    return <div>You are not authenticated! Please login.</div>;
  }

  return <div>Authenticated content</div>;
}
```

`useAuth` exports an object with the following properties:

- `isLoading`: A boolean that indicates whether the `useAuth` function is currently checking if a user is authenticated.
- `isAuthenticated`: A boolean that indicates whether the user is authenticated.
- `authResult`: The result from checking if there is an authenticated user.

  If there is an authenticated user, the `authResult` will be `true`. Otherwise, the `authResult` will be an object with the following properties:

  ```js title="The authResult object when there is no authenticated user"
  {
    /**
     * An absolute URL to the WordPress backend that the user should be redirected to in order to authenticate.
     * This property is used for the "redirect" based authentication strategy
     */
    redirect: 'xxxx';

    /*
     * A relative URL path to the local login page as specified in the `loginPagePath` option.
     * This property is used for the "local" based authentication strategy
     */
    login: 'xxxx';
  }
  ```

  The `authResult` can be helpful if you want to handle the redirection yourself, instead of the `useAuth` hook.

### `useLogin`

The `useLogin` hook provides an abstraction around obtaining an authorization code and fetching refresh/access tokens from WordPress, thus logging in a user to your Headless frontend.

The following example shows how to use the `useLogin` hook to login a user:

```tsx title=pages/login.tsx {9,18}
import { client } from 'client';
import { useState } from 'react';

export default function Login() {
  const { useLogin } = client.auth;
  const [usernameEmail, setUserNameEmail] = useState('');
  const [password, setPassword] = useState('');

  const { login, isLoading, data, error } = useLogin();

  const errorMessage = data?.error || error?.message;

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();

        login(usernameEmail, password);
      }}
    >
      <div>
        <div>
          <label htmlFor="usernameEmail">Username or Email</label>
        </div>
        <div>
          <input
            type="text"
            value={usernameEmail}
            onChange={(e) => setUserNameEmail(e.target.value)}
            id="usernameEmail"
          />
        </div>

        <div>
          <label htmlFor="password">Password</label>
        </div>
        <div>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            id="password"
          />
        </div>

        <div>
          <button type="submit">Login</button>
        </div>
      </div>

      {errorMessage ? <p>Error: {errorMessage}</p> : null}
    </form>
  );
}
```

`useLogin` exports an object with the following properties:

- `login`: A function that initiates a request to obtain an authorization code via a GraphQL mutation by the provided `usernameEmail` and `password` arguments. Note that the `usernameEmail` argument is a string that can be either a username or an email address.
- `isLoading`: A boolean that indicates whether the `login` function is currently fetching an authorization code.
- `data`: An object that contains the response data from the `login` function.
- `error`: An object that contains the error data from the `login` function.

When an authorization code is successfully fetched, `useLogin` will facilitate the request to the WPE Headless authorize endpoint to obtain the refresh/access tokens. From there, the tokens are stored properly, and the user is logged in.

Additionally, if the login page URL contains a `redirect_uri` query parameter, the user will be redirected to the `redirect_uri` URL after the login is successful.

### `useLogout`

The `useLogout` hook provides a way to logout a user from your headless frontend.

The following example shows how you could use the `useLogout` hook in a `logout.tsx` page:

```tsx title="src/pages/logout.tsx"
import { client } from 'client';
import { useRouter } from 'next/router';
import { useEffect } from 'react';
export default function Logout() {
  const router = useRouter();
  const { isLoggedOut, logout } = client.auth.useLogout();
  useEffect(() => {
    if (isLoggedOut !== undefined) {
      return;
    }

    // Initiate the logout process.
    // This could also be called on a button click, for example, in a nav menu.
    logout();
  }, [isLoggedOut, logout]);

  useEffect(() => {
    if (isLoggedOut) {
      // The user was successfully logged out. Redirect them.
      router.push('/');
    }
  }, [router, isLoggedOut]);
  return <>Logging out...</>;
}
```

`useLogout` exports an object with the following properties:

- `logout`: a function that initiates a request to logout the user by clearing their refresh token from the cookie.
- `isLoggedOut`: `undefiend` until the `logout` function is called. Then a `boolean` that indicates whether the user was successfully logged out
- `isLoading`: A boolean that indicates whether the `logout` function is currently logging out the user.

### Custom Queries and Mutations

GQty publishes the following hooks that can be used for custom queries, mutations, or subscriptions:

- [`useQuery`](https://gqty.dev/docs/react/fetching-data#usequery)
  - Make any query request to the Headless WordPress API
- [`useLazyQuery`](https://gqty.dev/docs/react/fetching-data#uselazyquery)
- [`useTransactionQuery`](https://gqty.dev/docs/react/fetching-data#usetransactionquery)
- [`useMutation`](https://gqty.dev/docs/react/mutations#usemutation)
  - Make any mutation request to the Headless WordPress API
- [`useSubscription`](https://gqty.dev/docs/react/subscriptions#usesubscription)

For example, you may want to get a list of your content types:

```tsx
const { useQuery } = client;

const contentTypes = useQuery().contentTypes()?.nodes;
```

`useQuery`, along with all the other hooks, are typed. So you'll be able to see exactly what kind of data you have access to via your IDE's intellisense.
